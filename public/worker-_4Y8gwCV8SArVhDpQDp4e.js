(()=>{self.__WB_MANIFEST;const e="todos",t="pending";let a;const o=()=>new Promise(((o,n)=>{const s=indexedDB.open("TodoDB",1);s.onerror=()=>n(s.error),s.onsuccess=()=>{a=s.result,o(a)},s.onupgradeneeded=a=>{const o=a.target.result;o.objectStoreNames.contains(e)||o.createObjectStore(e,{keyPath:"id"}),o.objectStoreNames.contains(t)||o.createObjectStore(t,{keyPath:"timestamp"})}})),n=async e=>{const o=a.transaction(t,"readwrite").objectStore(t);await o.delete(e)};self.addEventListener("install",(e=>{e.waitUntil(o())})),self.addEventListener("fetch",(n=>{n.request.url.includes("/api/todos")&&n.respondWith(async function(n){try{const e=await fetch(n);if(e.ok)return e}catch(e){console.log("Offline mode, using cached data")}a||await o();if("GET"===n.method){const t=a.transaction(e,"readonly").objectStore(e),o=await t.getAll();return new Response(JSON.stringify(o),{headers:{"Content-Type":"application/json"}})}{const o=await n.json(),s={request:{url:n.url,method:n.method,body:JSON.stringify(o)},timestamp:Date.now()};await(async e=>{const o=a.transaction(t,"readwrite").objectStore(t);await o.add(e)})(s);const r=a.transaction(e,"readwrite").objectStore(e);switch(n.method){case"POST":o.id=s.timestamp,await r.add(o);break;case"PUT":await r.put(o);break;case"DELETE":await r.delete(o.id)}return new Response(JSON.stringify(o),{headers:{"Content-Type":"application/json"}})}}(n.request))})),self.addEventListener("sync",(async e=>{if("sync-todos"===e.tag)try{a||await o();const e=await(async()=>a.transaction(t,"readonly").objectStore(t).getAll())();for(const t of e){(await fetch(t.request.url,{method:t.request.method,headers:{"Content-Type":"application/json"},body:t.request.body})).ok&&await n(t.timestamp)}}catch(e){console.error("Sync failed:",e)}}))})();